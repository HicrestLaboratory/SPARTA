#include "cuda_utilities.h"
#include "matrices.h"
#include "blocking.h"
#include "utilities.h"
#include <string.h>
#include <cuda_runtime_api.h>

using namespace std;



int main(int argc, char* argv[])
{
    //keep track of time
    float dt;
    vector<double> algo_times;
    float mean_time;
    float std_time;


    //import CSR
    CLineReader cli(argc, argv);
    if (cli.verbose_ > 0) cli.print();
    CSR cmat_A(cli); //sparse operand
    BlockingEngine bEngine(cli);


    //partition for the row of cmat_A
    vector<intT> partition;
    intT part_block_size = 5;
    for (intT i = 0; i < cmat_A.rows; i += part_block_size) partition.push_back(i);
    partition.push_back(cmat_A.rows);


    //create vbamt from equally spaced row partition of cmat_A;
    VBR vbmat; 
    if (cli.verbose_ > 0) cout << "Create VBR from reordered CSR" << endl;
    vbmat.fill_from_CSR(cmat_A, partition, cli.col_block_size_);
    if (cli.verbose_ > 1) vbmat.print();


    intT A_rows = cmat_A.rows;
    intT A_cols = cmat_A.cols;
    intT B_cols = A_rows;
#ifndef PICO_DEBUG
    intT B_rows = 100;
#else
    intT B_rows = A_cols;
#endif
    intT C_cols = A_cols;
    intT C_rows = B_rows;

    //dense operand
    DataT* mat_B = new DataT[B_rows * B_cols];

    //TODO initialize B with random numbers, not 1s
    for (intT i = 0; i < B_rows * B_cols; i++)
    {
        mat_B[i] = 1.;
    }

    //******************************************
    //****VBR by dense MULTIPLICATION PHASE***
    //******************************************


    DataT_C* mat_C_VBR = new DataT_C[C_rows * C_cols]{ 0 }; //will store result of dense-dense multiplication

#ifdef PICO_DEBUG
    printf("===================================== Input matrices =====================================\n");
    printf("File %s, line %d: print cmat_A\n", __FILE__, __LINE__);
    cmat_A.print(2);
    pico_print_SpMMM("NULL", 0, 0, 0, NULL, NULL, NULL, "mat_B", B_rows, B_cols, mat_B, "mat_C_VBR", C_rows, C_cols, mat_C_VBR);
    printf("==========================================================================================\n\n\n");
#endif

    //run the VBR-dense multiplications

    std::cout << "cublas start" << std::endl;

    for (int i = -cli.warmup_; i < cli.exp_repetitions_; i++)
    {
        cublas_blockmat_multiply(vbmat, mat_B, B_cols, B_rows, mat_C_VBR, C_rows, dt, 8);
        //only saves non-warmup runs
        if (i >= 0) algo_times.push_back(dt);
    }

    std::cout << "cublas end" << std::endl;

    //mean_time = mean(algo_times);
    //std_time = std_dev(algo_times);
    //algo_times.clear();

//     delete[] mat_C_VBR;



    //******************************************
    //****Sparse by dense MULTIPLICATION PHASE***
    //******************************************


    //TODO



    //******************************************
    //****VBR by dense MULTIPLICATION PHASE***
    //******************************************

    std::cout << "==================================== cusparse start ======================================" << std::endl;

    DataT_C* mat_C_VBR2 = new DataT_C[C_rows * C_cols]{ 0 };

    DataT *csrVal;
    int *csrRowPtr, *csrColInd;
    prepare_cusparse_CSR( cmat_A, &csrRowPtr, &csrColInd, &csrVal);

#ifdef PICO_DEBUG
    printf("print CSR generated by \"prepare_cusparse_CSR\":\n");
    pico_print_SpMMM("cmat_A", A_rows, A_cols, cmat_A.nztot(), csrRowPtr, csrColInd, csrVal, "NULL", 0, 0, NULL, "NULL", 0, 0, NULL);
#endif

    cudaDeviceSynchronize();
    std::cout << "------------------------------- prepare_cusparse_CSR done --------------------------------" << std::endl;
    cusparse_gemm_custom2(C_rows, B_rows, (int) cmat_A.nztot(), csrRowPtr, csrColInd, csrVal, mat_B, B_cols, B_cols, mat_C_VBR2, C_cols, 1, 1, dt); // BUG qui

    std::cout << "===================================== cusparse end =======================================" << std::endl;

    int cmp = memcmp(mat_C_VBR, mat_C_VBR2, C_rows * C_cols * sizeof(DataT_C) );
    std::cout << "memcmp of mat_C_VBR and mat_C_VBR2 is " << cmp << std::endl;

    DataT_C* mat_C_VBR3 = new DataT_C[C_rows * C_cols]{ 0 };
    cmp = memcmp(mat_C_VBR3, mat_C_VBR2, C_rows * C_cols * sizeof(DataT_C) );
    std::cout << "memcmp of mat_C_VBR3 and mat_C_VBR2 is " << cmp << std::endl;

    //TODO

    std::cout << "END" << std::endl;

}
